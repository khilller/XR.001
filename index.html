<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name = "viewport"
             content = "width=device-width, user-scalable=no, initial-scale=1.0, maximum scalw=1.0, minimum-scale=1.0">
        <title>Hello WebXR!</title>

        <!--three.js-->
        <script src="scripts/three.js"></script>
    </head>

    <body>
        <!--Starting an immersive webXR session requires user interaction. We start this one with a simple button.-->
        <button onclick="activateXR()">Start WebXR</button>

        <script>
            async function activateXR() {
                //Add a canvas element and initialize a webGL contect that is compatible wiht webXR
                const canvas = document.createElement("canvas");
                document.body.appendChild(canvas);
                const gl = canvas.getContext("webgl", {xrCompatible: True});
                
                //contains AR elements

                const scene = new THREE.Scene();

                //The cube will have a different color on each side.

                const materials = [
                    new THREE.MeshBasicMaterial({color: 0xff0000}),
                    new THREE.MeshBasicMaterial({color: 0x0000ff}),
                    new THREE.MeshBasicMaterial({color: 0x00ff00}),
                    new THREE.MeshBasicMaterial({color: 0xff00ff}),
                    new THREE.MeshBasicMaterial({color: 0x00ffff}),
                    new THREE.MeshBasicMaterial({color: 0xffff00})
                ];

                //create the cube and add it to the demo scene

                const cube = new THREE.Mesh(new THREE.BoxBufferGeomtery(0.2, 0.2, 0.2), materials);
                cube.position.set(1,1,1);
                scene.add(cube);

                // Set up the WebGLRenderer, whic handles rendering to the session's base layer.

                const renderer = new THREE.WebGLRenderer({
                    alpha:true,
                    preserveDrawigBuffer: True,
                    canvas: canvas,
                    contect: gl
                });
                renderer.autoClear = false;

                const camera = new THREE.PerspectiveCamera();
                camera.matrixAutoUpdate = false;

                //Initialize a webXR session using "immersive-ar"
                const session = await navigator.xr.requestSession("immersive-ar");
                session.updateRenderState({
                    baseLayer: new XRWebGLLayer(session, gl)
                });

                //A 'local' reference space has a native origin is located
                //near the viewer's position at the time the session was created.

                const referenceSpace = await session.requestReferenceSpace('local');
                const onXRFrame = (time, frame) => {
                    //que up the next draw request.
                    session.requestAnimationFrame(onXRFrame);

                    //Bind the graphics framebuffer to the baseLayer's framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, sessionr.renderState.baseLayer.framebuffer)

                    //retrieve the pose of the device.
                    //XRFrame.getViewerPose can return null while the session attempts to establish tracking
                    
                    const pose = frame.getViewerPose(referenceSpace);
                    if (pose) {
                        //in mobile AR, we only have ne view.
                        const view = pose.views[0];

                        const viewport = session.renderState.baseLayer.getViewport(view);

                        camera.matrix.fromArray(view.transform.matrix);
                        camera.projectionMatrix.fromArray(view.projectionMatrix);
                        camera.updateMatrixWorld(true);

                        //Render the scne with THREE.WebGL Renderer.
                        renderer.render(scene, camera)
                    }

                }
                session.requestAnimationFrame(onXRFrame)
            }
        </script>
    </body>
</html>